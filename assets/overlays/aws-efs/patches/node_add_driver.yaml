kind: DaemonSet
apiVersion: apps/v1
metadata:
  name: aws-efs-csi-driver-node
  namespace: ${NAMESPACE}
  annotations:
    config.openshift.io/inject-proxy-cabundle: csi-driver
spec:
  selector:
    matchLabels:
      app: aws-efs-csi-driver-node
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 10%
  template:
    metadata:
      labels:
        app: aws-efs-csi-driver-node
      annotations:
        target.workload.openshift.io/management: '{"effect": "PreferredDuringScheduling"}'
        # This annotation prevents eviction from the cluster-autoscaler
        cluster-autoscaler.kubernetes.io/enable-ds-eviction: "false"
    spec:
      hostNetwork: true
      serviceAccount: aws-efs-csi-driver-node-sa
      priorityClassName: system-node-critical
      dnsPolicy: ClusterFirstWithHostNet
      tolerations:
        - operator: Exists
      nodeSelector:
        kubernetes.io/os: linux
      initContainers:
        - name: init-aws-credentials-file
          image: ${TOOLS_IMAGE}
          command:
          - sh
          - -c
          - |
            # Define file path variables
            CREDENTIALS_FILE=/var/run/aws/keys/credentials
            AUTH_CREDENTIALS_FILE=/var/run/aws/auth/credentials
            AWS_ACCESS_KEY_ID_FILE=/var/run/aws/keys/aws_access_key_id
            AWS_SECRET_ACCESS_KEY_FILE=/var/run/aws/keys/aws_secret_access_key

            # If credentials key exists in ebs-cloud-credentials secret, then use it as the auth file
            if [ -e "$CREDENTIALS_FILE" ]; then
                cp "$CREDENTIALS_FILE" "$AUTH_CREDENTIALS_FILE"
                echo "Kubernetes Secret already contains credentials file, copied to the right place: $AUTH_CREDENTIALS_FILE"
                exit 0
            fi

            # Otherwise, make sure the access keys are mounted in the pod...
            if [ ! -e "$AWS_ACCESS_KEY_ID_FILE" ] || [ ! -e "$AWS_SECRET_ACCESS_KEY_FILE" ]; then
                echo "AWS keys not found"
                exit 1
            fi

            # And create an auth file based on those keys
            cat <<-EOF > "$AUTH_CREDENTIALS_FILE"
            [default]
            aws_access_key_id=$(cat "$AWS_ACCESS_KEY_ID_FILE")
            aws_secret_access_key=$(cat "$AWS_SECRET_ACCESS_KEY_FILE")
            EOF
            echo "Kubernetes Secret does not have credentials file, created a fresh one at $AUTH_CREDENTIALS_FILE"
          volumeMounts:
            - name: aws-keys
              mountPath: /var/run/aws/keys
              readOnly: true
            - name: aws-auth
              mountPath: /var/run/aws/auth
          terminationMessagePolicy: FallbackToLogsOnError
      containers:
        - name: csi-driver
          securityContext:
            privileged: true
          image: ${DRIVER_IMAGE}
          args:
            - --endpoint=$(CSI_ENDPOINT)
            - --logtostderr
            - --v=${LOG_LEVEL}
          env:
            - name: CSI_ENDPOINT
              value: unix:/csi/csi.sock
            - name: AWS_SDK_LOAD_CONFIG
              value: '1'
            - name: AWS_CONFIG_FILE
              value: /var/run/aws/auth/credentials
          volumeMounts:
            - name: kubelet-dir
              mountPath: /var/lib/kubelet
              mountPropagation: "Bidirectional"
            - name: socket-dir
              mountPath: /csi
            - name: efs-state-dir
              mountPath: /var/run/efs
            - name: efs-utils-config
              mountPath: /var/amazon/efs
            - name: efs-utils-config-legacy
              mountPath: /etc/amazon/efs-legacy
            - name: etc-selinux
              mountPath: /etc/selinux
            - name: sys-fs
              mountPath: /sys/fs
            - name: aws-auth
              mountPath: /var/run/aws/auth
              readOnly: true
            - name: bound-sa-token
              mountPath: /var/run/secrets/openshift/serviceaccount
              readOnly: true
          ports:
            - name: healthz
              # Due to hostNetwork, this port is open on all nodes!
              containerPort: 10303
              protocol: TCP
          livenessProbe:
            httpGet:
              host: 127.0.0.1
              path: /healthz
              port: healthz
            initialDelaySeconds: 10
            timeoutSeconds: 3
            periodSeconds: 10
            failureThreshold: 5
          resources:
            requests:
              memory: 50Mi
              cpu: 10m
            # The CSI driver can consume a lot of memory if many volumes are created at once. This is
            # intended to prevent the driver from adding undue stress to control-plane nodes.
            limits:
              memory: 1Gi
          terminationMessagePolicy: FallbackToLogsOnError
        - name: csi-node-driver-registrar
          securityContext:
            privileged: true
          image: ${NODE_DRIVER_REGISTRAR_IMAGE}
          args:
            - --csi-address=/csi/csi.sock
            - --http-endpoint=:10305
            - --v=${LOG_LEVEL}
          lifecycle:
            preStop:
              exec:
                command: ["/bin/sh", "-c", "rm -rf /registration/efs.csi.aws.com-reg.sock /csi/csi.sock"]
          ports:
            - containerPort: 10305
              name: rhealthz
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /healthz
              port: rhealthz
            initialDelaySeconds: 10
            timeoutSeconds: 3
            periodSeconds: 10
            failureThreshold: 5
          volumeMounts:
            - name: socket-dir
              mountPath: /csi
            - name: registration-dir
              mountPath: /registration
          resources:
            requests:
              memory: 50Mi
              cpu: 10m
          terminationMessagePolicy: FallbackToLogsOnError
        - name: csi-liveness-probe
          image: ${LIVENESS_PROBE_IMAGE}
          args:
            - --csi-address=/csi/csi.sock
            - --probe-timeout=3s
            - --health-port=10303
            - --v=${LOG_LEVEL}
          volumeMounts:
            - name: plugin-dir
              mountPath: /csi
          resources:
            requests:
              memory: 50Mi
              cpu: 10m
          terminationMessagePolicy: FallbackToLogsOnError
      volumes:
        - name: kubelet-dir
          hostPath:
            path: /var/lib/kubelet
            type: Directory
        - name: registration-dir
          hostPath:
            path: /var/lib/kubelet/plugins_registry/
            type: Directory
        - name: efs-state-dir
          hostPath:
            path: /var/run/efs
            type: DirectoryOrCreate
        - name: efs-utils-config
          hostPath:
            path: /var/amazon/efs
            type: DirectoryOrCreate
        - name: efs-utils-config-legacy
          hostPath:
            path: /etc/amazon/efs
            type: DirectoryOrCreate
        - name: etc-selinux
          hostPath:
            path: /etc/selinux
            type: DirectoryOrCreate
        - name: sys-fs
          hostPath:
            path: /sys/fs
            type: Directory
        - name: aws-keys
          secret:
            secretName: node-aws-efs-cloud-credentials
        - name: aws-auth
          emptyDir: {}
        # This service account token can be used to provide identity outside the cluster.
        # For example, this token can be used with AssumeRoleWithWebIdentity to authenticate with AWS using IAM OIDC provider and STS.
        - name: bound-sa-token
          projected:
            sources:
              - serviceAccountToken:
                  path: token
                  audience: openshift
